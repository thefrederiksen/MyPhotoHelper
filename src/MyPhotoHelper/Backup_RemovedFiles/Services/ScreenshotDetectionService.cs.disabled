using CSnakes.Runtime;

namespace FaceVault.Services;

public class ScreenshotDetectionService : IScreenshotDetectionService
{
    private readonly IPythonEnvironment _pythonEnv;
    private readonly ILogger<ScreenshotDetectionService> _logger;

    public ScreenshotDetectionService(IPythonEnvironment pythonEnv, ILogger<ScreenshotDetectionService> logger)
    {
        _pythonEnv = pythonEnv;
        _logger = logger;
    }

    public async Task<ScreenshotDetectionResult> DetectScreenshotAsync(string filePath)
    {
        try
        {
            _logger.LogDebug("Analyzing screenshot for: {FilePath}", filePath);

            // Call Python screenshot detection method
            var result = await Task.Run(() =>
            {
                return _pythonEnv.Screenshots().DetectScreenshot(filePath);
            });

            // Extract results from Python tuple (is_screenshot, confidence, details)
            var isScreenshot = (bool)result.Item1;
            var confidence = (double)result.Item2;
            var details = (Dictionary<string, object>)result.Item3;

            // Parse detailed analysis from Python
            var analysisDetails = ParseAnalysisDetails(details);

            return new ScreenshotDetectionResult
            {
                IsScreenshot = isScreenshot,
                Confidence = confidence,
                FilePath = filePath,
                Analysis = details,
                AnalyzedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting screenshot for file: {FilePath}", filePath);
            
            return new ScreenshotDetectionResult
            {
                IsScreenshot = false,
                Confidence = 0.0,
                FilePath = filePath,
                Error = ex.Message,
                AnalyzedAt = DateTime.UtcNow
            };
        }
    }

    public async Task<bool> IsScreenshotAsync(string filePath)
    {
        var result = await DetectScreenshotAsync(filePath);
        return result.IsScreenshot;
    }

    public async Task<double> GetScreenshotConfidenceAsync(string filePath)
    {
        var result = await DetectScreenshotAsync(filePath);
        return result.Confidence;
    }

    private ScreenshotAnalysisDetails ParseAnalysisDetails(Dictionary<string, object> details)
    {
        var analysis = new ScreenshotAnalysisDetails();

        try
        {
            // Parse filename analysis
            if (details.ContainsKey("filename") && details["filename"] is Dictionary<string, object> filenameDict)
            {
                analysis.Filename = new FilenameAnalysis
                {
                    Filename = filenameDict.GetValueOrDefault("filename", "")?.ToString() ?? "",
                    Matches = ParseStringList(filenameDict.GetValueOrDefault("matches", new List<object>())),
                    Score = Convert.ToDouble(filenameDict.GetValueOrDefault("score", 0.0))
                };
            }

            // Parse EXIF analysis
            if (details.ContainsKey("exif") && details["exif"] is Dictionary<string, object> exifDict)
            {
                analysis.Exif = new ExifAnalysis
                {
                    HasExif = Convert.ToBoolean(exifDict.GetValueOrDefault("has_exif", false)),
                    CameraMake = exifDict.GetValueOrDefault("camera_make", null)?.ToString(),
                    CameraModel = exifDict.GetValueOrDefault("camera_model", null)?.ToString(),
                    Software = exifDict.GetValueOrDefault("software", null)?.ToString(),
                    Score = Convert.ToDouble(exifDict.GetValueOrDefault("score", 0.0))
                };
            }

            // Parse dimension analysis
            if (details.ContainsKey("dimensions") && details["dimensions"] is Dictionary<string, object> dimensionsDict)
            {
                analysis.Dimensions = new DimensionAnalysis
                {
                    Width = Convert.ToInt32(dimensionsDict.GetValueOrDefault("width", 0)),
                    Height = Convert.ToInt32(dimensionsDict.GetValueOrDefault("height", 0)),
                    AspectRatio = Convert.ToDouble(dimensionsDict.GetValueOrDefault("aspect_ratio", 0.0)),
                    MatchesScreenResolution = Convert.ToBoolean(dimensionsDict.GetValueOrDefault("matches_screen_resolution", false)),
                    MatchesCommonRatio = dimensionsDict.GetValueOrDefault("matches_common_ratio", null) != null 
                        ? Convert.ToDouble(dimensionsDict["matches_common_ratio"]) 
                        : null,
                    Score = Convert.ToDouble(dimensionsDict.GetValueOrDefault("score", 0.0))
                };
            }

            // Parse content analysis
            if (details.ContainsKey("content") && details["content"] is Dictionary<string, object> contentDict)
            {
                analysis.Content = new ContentAnalysis
                {
                    ColorAnalysis = Convert.ToDouble(contentDict.GetValueOrDefault("color_analysis", 0.0)),
                    EdgeAnalysis = Convert.ToDouble(contentDict.GetValueOrDefault("edge_analysis", 0.0)),
                    UniformityAnalysis = Convert.ToDouble(contentDict.GetValueOrDefault("uniformity_analysis", 0.0)),
                    Score = Convert.ToDouble(contentDict.GetValueOrDefault("score", 0.0)),
                    Error = contentDict.GetValueOrDefault("error", null)?.ToString()
                };
            }

            // Parse overall scores
            analysis.TotalScore = Convert.ToDouble(details.GetValueOrDefault("total_score", 0.0));
            analysis.MaxScore = Convert.ToDouble(details.GetValueOrDefault("max_score", 0.0));
            analysis.Confidence = Convert.ToDouble(details.GetValueOrDefault("confidence", 0.0));
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error parsing analysis details");
        }

        return analysis;
    }

    private List<string> ParseStringList(object? listObj)
    {
        if (listObj is IEnumerable<object> enumerable)
        {
            return enumerable.Select(item => item?.ToString() ?? "").ToList();
        }
        return new List<string>();
    }
}